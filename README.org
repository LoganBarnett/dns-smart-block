#+title:     DNS Smart Block
#+author:    Logan Barnett
#+email:     logustus@gmail.com
#+date:      <2025-11-17 Mon>
#+language:  en
#+file_tags:
#+tags:

Provide DNS blocking dynamically using an LLM to analyze a domain.  This is
helpful in circumstances where existing block lists aren't enough, or you want
something that can get ahead of human submission of domains to block.

* Overview

DNS Smart Block is an orchestration system for smart DNS blocking using LLMs.
The system watches DNS logs, queues domain lookups, fetches content from those
domains, and uses an LLM to classify whether they match categories you're
interested in blocking.

The system is DNS-server agnostic and can work with any DNS server that
supports blocklists.  Blocked domains are served via a web API that outputs
plain text blocklists compatible with most DNS servers (Blocky, dnsmasq, BIND,
Unbound, AdGuard Home, Pi-hole, etc.).

DNS Smart Block consists of three main components:

1. *Log Processor* - Watches DNS server logs and enqueues domains that appear
   in DNS requests.  When a DNS lookup occurs, it's written to the log, and
   the log processor adds it to the work queue.

2. *Queue Processor* - Consumes domains from the queue, fetches data from each
   domain (HTTP GET with redirect following), and feeds the content to an LLM.
   The LLM classifies the site based on your interested categories.  If the
   site matches, the classification is stored in the database.

3. *Blocklist Server* - Web API that serves DNS blocklists from the database.
   Your DNS server periodically fetches the blocklist via HTTP to stay
   up-to-date with newly classified domains.

So the DNS request and queue flow looks like this:

#+begin_src d2 :results verbatim :exports results
initial_query: "DNS client sends query"
dns_handle: "DNS server handles request"

direction: down

parallel_flows: {
  grid-gap: 4
  dns_to_upstream: "DNS server forwards to upstream"

  dns_log: "DNS server logs request"
  log_processor: "log processor enqueues domain"
  queue_processor: "queue processor fetches & classifies"
  database: "classification stored in database"
  blocklist_server: "blocklist server serves via HTTP"
  dns_reload: "DNS server fetches updated blocklist"

  dns_log -> log_processor -> queue_processor -> database -> blocklist_server -> dns_reload
}

initial_query --> dns_handle
dns_handle -> parallel_flows.dns_to_upstream
dns_handle -> parallel_flows.dns_log
#+end_src

#+RESULTS:
#+begin_example
                        ┌───────────────────────┐
                        │DNS client sends query │
                        │                       │
                        └───────────────────────┘
                                  │
                                  ▼
                      ┌───────────────────────────┐
                      │DNS server handles request │
                      │                           │
                      └───────────────────────────┘
                              │       │
                              │       └─────────┐
                              │                 │
 ┌────────────────────────────│─────────────────│──────────────────┐
 │                         parallel_flows       │                  │
 │                            ▼                 ▼                  │
 │    ┌──────────────────────────────┌────────────────────────┐    │
 │    │DNS server forwards to upstrea│DNS server logs request │    │
 │    │                              │ │                      │    │
 │    └──────────────────────────────└────────────────────────┘    │
 │                                              │                  │
 │                                              ▼                  │
 │                                ┌──────────────────────────────┐ │
 │                                │log processor enqueues domain │ │
 │                                │                              │ │
 │                                └──────────────────────────────┘ │
 │                                              │                  │
 │                                              ▼                  │
 │                               ┌─────────────────────────────────────┐
 │                               │queue processor fetches & classifies │
 │                               │                                 │   │
 │                               └─────────────────────────────────────┘
 │                                              │                  │
 │                                              ▼                  │
 │                                ┌──────────────────────────────────┐
 │                                │classification stored in database │
 │                                │                                │ │
 │                                └──────────────────────────────────┘
 │                                              │                  │
 │                                              ▼                  │
 │                                ┌─────────────────────────────────┐
 │                                │blocklist server serves via HTTP││
 │                                │                                ││
 │                                └─────────────────────────────────┘
 │                                              │                  │
 │                                              ▼                  │
 │                              ┌─────────────────────────────────────┐
 │                              │DNS server fetches updated blocklist │
 │                              │                                  │  │
 │                              └─────────────────────────────────────┘
 │                                                                 │
 └─────────────────────────────────────────────────────────────────┘
#+end_example

* Components

** Log Processor

Watches DNS server logs and queues domains for classification.

*** Features
- Watches log files or command output (e.g., ~journalctl~)
- Parses multiple DNS log formats
- Deduplicates domains in memory
- Checks database to avoid re-queuing already classified domains
- Publishes to NATS queue

*** Usage
#+begin_src sh :exports code
dns-smart-block-log-processor \
  --log-source "cmd:journalctl -f -u dns-server" \
  --nats-url "nats://localhost:4222" \
  --database-url "postgresql://user@localhost/dns_smart_block" \
  --database-password-file "/run/secrets/db-password"
#+end_src

** Queue Processor

Processes queued domains: fetches content, classifies with LLM, stores results.

*** Features
- Consumes from NATS queue
- Runs classifier as subprocess for isolation
- Stores classifications with TTL (configurable, default 10 days)
- Event-sourced database design (immutable event log)
- Confidence threshold filtering

*** Usage
#+begin_src sh :exports code
dns-smart-block-queue-processor \
  --nats-url "nats://localhost:4222" \
  --database-url "postgresql://user@localhost/dns_smart_block" \
  --database-password-file "/run/secrets/db-password" \
  --classifier-path "dns-smart-block-classifier" \
  --ollama-url "http://localhost:11434" \
  --ollama-model "llama2" \
  --prompt-template "./prompts/gaming-classifier.txt" \
  --classification-type "gaming" \
  --min-confidence 0.8 \
  --classification-ttl-days 10
#+end_src

** Blocklist Server

HTTP API for serving DNS blocklists.

*** Features
- Plain text output (one domain per line)
- Filter by classification type (gaming, news, sports, etc.)
- Point-in-time queries via ~at~ parameter
- Compatible with any DNS server that supports HTTP blocklists

*** Usage
#+begin_src sh :exports code
dns-smart-block-blocklist-server \
  --database-url "postgresql://user@localhost/dns_smart_block" \
  --database-password-file "/run/secrets/db-password" \
  --bind-address "0.0.0.0:3000"
#+end_src

*** API Endpoints

**** GET /blocklist

Query parameters:
- ~type~ (required): Classification type (e.g., "gaming", "news", "sports")
- ~at~ (optional): ISO 8601 timestamp for historical queries (defaults to now)

Examples:
#+begin_src sh :exports code
# Current gaming blocklist
curl "http://localhost:3000/blocklist?type=gaming"

# Historical query (what was blocked at specific time)
curl "http://localhost:3000/blocklist?type=gaming&at=2025-01-22T10:00:00Z"

# Sports blocklist
curl "http://localhost:3000/blocklist?type=sports"
#+end_src

Output format (plain text, one domain per line):
#+begin_example
example-gaming-site.com
another-game-site.net
gaming-platform.org
#+end_example

**** GET /health

Health check endpoint.

** Classifier

Standalone binary that fetches a domain and classifies it using an LLM.

*** Features
- HTTP GET with redirect following
- HTML metadata extraction (title, description, Open Graph tags)
- LLM classification via Ollama
- JSON output for machine parsing
- Semantic error types
- Prompt hash computation for deduplication

*** Usage
#+begin_src sh :exports code
dns-smart-block-classifier \
  --domain "example.com" \
  --ollama-url "http://localhost:11434" \
  --ollama-model "llama2" \
  --prompt-template "./prompts/gaming-classifier.txt" \
  --output json
#+end_src

* DNS Server Integration

The blocklist server provides plain text output compatible with most DNS servers.

** Blocky

#+begin_src yaml :exports code
blocking:
  denylists:
    gaming:
      - http://localhost:3000/blocklist?type=gaming
    news:
      - http://localhost:3000/blocklist?type=news
#+end_src

** dnsmasq

#+begin_src sh :exports code
# Download and convert to dnsmasq format
curl "http://localhost:3000/blocklist?type=gaming" | \
  awk '{print "address=/"$1"/"}' > /etc/dnsmasq.d/gaming-blocklist.conf

# Reload dnsmasq
systemctl reload dnsmasq
#+end_src

** BIND

#+begin_src sh :exports code
# Download and convert to BIND format
curl "http://localhost:3000/blocklist?type=gaming" | \
  awk '{print "zone \""$1"\" { type master; file \"/etc/bind/null.zone\"; };"}' \
  > /etc/bind/gaming-blocklist.conf

# Reload BIND
rndc reload
#+end_src

** Unbound

#+begin_src sh :exports code
# Download and convert to Unbound format
curl "http://localhost:3000/blocklist?type=gaming" | \
  awk '{print "local-zone: \""$1"\" static"}' > /etc/unbound/gaming-blocklist.conf

# Reload Unbound
unbound-control reload
#+end_src

** Pi-hole / AdGuard Home

These DNS servers support direct HTTP blocklist URLs:

- Pi-hole: Add ~http://localhost:3000/blocklist?type=gaming~ to blocklists
- AdGuard Home: Add to DNS blocklists in settings

* Host Configuration

** Nix / NixOS

DNS Smart Block provides a comprehensive NixOS module for declarative
service configuration.

*** Quick Start

Add to your NixOS flake configuration:

#+begin_src nix :exports code
{
  inputs.dns-smart-block.url = "github:yourusername/dns-smart-block";

  outputs = { nixpkgs, dns-smart-block, ... }: {
    nixosConfigurations.myhost = nixpkgs.lib.nixosSystem {
      modules = [
        dns-smart-block.nixosModules.default
        {
          services.dns-smart-block = {
            enable = true;

            # Watch DNS server logs via journalctl
            logProcessor.logSource = "cmd:journalctl -f -u dns-server";

            # LLM configuration
            ollama.url = "http://localhost:11434";
            ollama.model = "llama2";

            # Use the bundled gaming classifier
            classifier.preset = "gaming";

            # Blocklist server
            blocklistServer.enable = true;
            blocklistServer.bindAddress = "0.0.0.0:3000";
          };
        }
      ];
    };
  };
}
#+end_src

*** Features

The NixOS module provides:

- *Built-in NATS server* - Dedicated instance that won't conflict with
  other NATS services
- *Built-in PostgreSQL* - Automatic database setup with peer authentication
- *Systemd services* - Automatically configured log-processor, queue-processor,
  and blocklist-server
- *Security hardening* - Services run as DynamicUser with restricted
  permissions
- *Proper permissions* - Log-processor gets =systemd-journal= group for
  reading logs
- *Flexible log sources* - Support for both journalctl and file-based
  log watching
- *Secret management* - Compatible with agenix, sops-nix for passwords

*** Configuration Options

Key configuration options:

#+begin_src nix :exports code
services.dns-smart-block = {
  # Enable the service
  enable = true;

  # NATS configuration
  nats.enable = true;              # Use built-in NATS
  nats.port = 4222;                # Port (change if conflicts)

  # Database
  database.enable = true;          # Use built-in PostgreSQL
  database.passwordFile = "/run/secrets/db-password";

  # Log processor
  logProcessor.enable = true;
  logProcessor.logSource = "cmd:journalctl -f -u dns-server";

  # Queue processor
  queueProcessor.enable = true;
  queueProcessor.minConfidence = 0.8;    # 0.0 to 1.0

  # Blocklist server
  blocklistServer.enable = true;
  blocklistServer.bindAddress = "0.0.0.0:3000";

  # Ollama LLM
  ollama.url = "http://localhost:11434";
  ollama.model = "llama2";

  # Classifier - use bundled preset or custom template
  classifier.preset = "gaming";        # Use bundled gaming classifier
  # classifier.customTemplate = ./custom-prompt.txt;  # Or provide custom
};
#+end_src

*** Monitoring

Check service status:

#+begin_src sh :exports code
systemctl status dns-smart-block-nats
systemctl status dns-smart-block-log-processor
systemctl status dns-smart-block-queue-processor
systemctl status dns-smart-block-blocklist-server

# View logs
journalctl -f -u dns-smart-block-*
#+end_src

* Database

DNS Smart Block uses PostgreSQL with an event-sourced architecture.

** Tables

- *prompts* - Stores LLM prompts with SHA256 hash deduplication
- *domain_classification_events* - Immutable event log (queued, classifying, classified, error)
- *domains* - Projection table for fast domain lookups
- *domain_classifications* - Classification results with TTL (valid_on, valid_until)

** Migrations

Migrations are automatically run by the queue-processor on startup.

Manual migration:
#+begin_src sh :exports code
sqlx migrate run --database-url "postgresql://user@localhost/dns_smart_block"
#+end_src

* Development

** Building

#+begin_src sh :exports code
# Build all components
cargo build --release

# Build specific component
cargo build --release -p dns-smart-block-log-processor
cargo build --release -p dns-smart-block-queue-processor
cargo build --release -p dns-smart-block-classifier
cargo build --release -p dns-smart-block-blocklist-server
#+end_src

** Testing

#+begin_src sh :exports code
# Run all tests
cargo test --all

# Run with database tests (requires PostgreSQL)
DATABASE_URL="postgresql://localhost/dns_smart_block_test" \
  cargo test --all -- --ignored
#+end_src

** Nix Development Shell

#+begin_src sh :exports code
nix develop
#+end_src

* License

[Your license here]
